
### Основы

Файлы terraform используют формат tf. В зависимости от провайдера (где устанавливаеться инфраструктура на облкае: AWS, Azure, ... или же на локальном вервере: proxmox, ...) функции и модули разняться. 

В начале мы прописываем с каким провайдером мы будем работать (мы будем рассматривать примеры с aws, в зависимости от провайдера параметры будут отличаться):
``` tf
provider "aws" {
	access_key = "..."
	secret_key = "..."
	region = "..."
}
```
для всех провайдеров нужно указывать свои параметры, в основном это ключи для захождения в систему в которй будет настраиваться архитектура.

Следующая сущность это resource которая представляет из себя какой-то объект в системе - хранилище, контейнер, виртуальную машину, и т.д. Для разных провайдеров можно создать разные ресурсы, и список параметров для них также будет отличаться (например виртуалки для proxmox и контейнеры для k8s, сервера для aws). После resource мы указываем какой именно объект мы создаём (смотрим в документацию), а затем даём ему название, как мы к нему будем обращаться и в {} параметры:
``` tf
resource "aws_instance" "my_Ubuntu" {
	param1 = "..."
	...
} 
```
В будущем эти ресурсы будут использоваться как переменные, и следовательно нам надо будет обращаться к ним по именам.

Параметры что для провайдера, что для всех ресурсов можно посмотреть в документации.

Следующие команды в cli запускают этот файл.
Для начала, в папке с tf файлами надо запустить команду
``` bash
terraform init
```
которая пробежиться по всем файлам и скачает все необходимый для указанных провайдеров файлы. Теперь код может быть правильно обработан провайдером.

Команда plan показывает, что будет происходить при запуске .tf файлов, какие изменения будут происходить
``` bash
terraform plan
```
Удобно для дебага.

Если мы согласны с планом то прописываем команду:
``` tf
terraform apply
```
Эта команда сделает все действия описанные в плане, т.е. инфраструктура на провайдере станет выглядеть как описано в файле.
После этого в директории появиться файл terraform.tfstate в котором будет описано состояние системы. При следующих применениях файлов .tf, террформ будет производить только те изменения, которые нужны, чтобы инфраструктура совпадала с описанной. Т.е. если мы применим файлик один раз, а потом сразу же второй, то ничего не измениться, так как инфраструктура уже совпадает с той что в файле.
Но если удалить конфигурационный файл (terraform.tfstate), то он не увидит уже выстроенную инфраструктуру, и будет выстраивать её по новому. Поэтому с terraform.tfstate файлом надо обращатсья очень аккуратно.

Если теперь менять какие-нибудь параметры ресурсов при apply это будет обновляться на провайдере.
Притом ручные изменения в отслеживаемых ресурсах будут сбрасываться, если они не внесены в tf файлы. Таким образом править ресурсы надо только через tf файлы.
Если ресурс отслеживаеться, т.е. лежит в terraform.tfstate, то при удалении его (просто удалить строки с его объявлением) удалиться ресурс на провайдере, потому что теперь терраформ видит что есть лишний не нужный ресурс.

Чтобы уничтожить всю инфраструктуру, можно не только стирать все ресурсы из файла tf, но а также командой:
``` bash
terraform destroy
```

### Зависимости

При задании аттрибутов ресурсов, можно обращаться к аттрибутам других ресурсов. Для этого мы обращаемся к нему как я ООП, сначала пишем тип ресурса, точка, название данное нами ресурсу, точка, и аттрибут этого ресурса (все аттрибуты которые есть у того или иного типа рессурса можно посмотреть в документации, или же в terraform.tfstate):
``` tf
vpc_security_group_id = aws_security_group.my_webserver.id
```
Таким образом создаёться зависимость.

Код в терраформ выполняется не линейно, терраформ учитывает зависимости и сначала создаёт ресурсу которые ни от каких других не зависят, потом зависящие только от них и т.д.

### Count

Count - это параметр, который можно добавить к любому ресурсу. Он принимает натуральное число, и именно столько экземпляров этого ресурса он создаст:
``` tf
resource "aws_instance" "my_Ubuntu" {
	count = 3
	param1 = "..."
	...
} 
```

