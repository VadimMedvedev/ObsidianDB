
### Асинхронность

Надо отличать асинхронность от других понятий, таких как: многопоточность и многопроцесность:
1) Многопроцессность - отдельные функции программы запускаются как отдельные процессы, и каждый процесс отдельно обрабатываеться процессором, т.е. каждая такая функция даёться какому-то ядру и оно его выполняет. Помогает с тяжёлыми процессами, которые требуют высоких вычислительных мощностей, которые можно производить параллельно (для этого использвуеться библиотека multiprocessing).
2) Многопоточность - несколько функций выполняються одновременно внутри одного процесса. Т.е. теперь не выделяются отдельные процессы под функции, а они выполняються по переменно внутри одного процесса. Это удобно когда нужно выполнить несколько легковесных функций вместе одновременно. Но когда потоков в процессе становиться слишком много, то процессу приходиться слишком часто переключаться между потоками, из-за чего начинает страдать производительность. (для этого использвуеться библиотека threading).
3) Асинхронность - Несколько функций запущенны одновременно в одном потоке, но каждая из них работает только когда к ней обращаються. То есть по сути все данные связанные с функциями храняться, и как только происходит какое-то новое обращение к функции, она быстро выдаёт ответ (или же нет, в завсимости от функции, return None) и программ идёт выполняться дальше. Проблема возникает тогда, когда одна из функций при работе выполняет команду требующую долгого выполнения, тогда другие функции не выполняються и асинхронности как таковой нет.

### Синтаксис

Во первых мы добавляем фреймворк asyncio в код:
``` python
import asyncio
```

Затем перед каждой функцией, от которой мы будем требовать асинхронность, будем писать async:
``` python
async def print1():
	print(1)
```

Чтобы теперь запустить выполнение асинхронных функций мы должны написать:
``` python
asyncio.run(main())
```
где main - точка входа, главная функция.

Команды, которые могут долго ждать ответа, но по сути сами ничего не делают, помечаються словом await перед ними. Когда асинхронная функция доходит до такой команды, она передаёт управление обратно, пока ответ на команду с await не придёт.
``` python
async def print2():
	await asyncio.sleep(10)
	print(2)
```
(здесь используеться таймер из той же библиотеки asyncio, потому что таймер из time делает видимость что всё это время работает, а не ждёт исхода времени).

Как +- должна выглядить основная функция main:
``` python
async def main():
	task1 = asincio.create_task(print1())
	task2 = asincio.create_task(print2())
	
	await task1
	await task2
```
Здесь функция create_task подразумевает что создаёться задание или несколько, которые затем нужно будет выполнить вместе асинхронно.

