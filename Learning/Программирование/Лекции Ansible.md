
https://docs.ansible.com/projects/ansible/latest/index.html - документация ansible
https://jinja.palletsprojects.com/en/stable/templates/ - документация Jinja
### Основные понятия

inventory - это файл где перечислены все наши машины и сервера, где они объеденены в группы и т.д. На них указаны ip адреса, порты, и имена пользователей на этом устройстве.
``` yaml
[group_name]
server-1
server-2 ansible_host=10.10.10.2 ansible_port=23 ansible_user=vadim
```


task - минимальная единица которую ансибл может выполнить, конкретная задача, в нём описываються действия для выполнения. Каждый таск должен иметь имя, к нему должны быть прикреплены быть модули (отдельные программы, которые выполняют то или иное действие, не shell команды!! это декларативное описание того что мы хотим, а не императивное пересчисление что нужно сделать!!).
```
- name: Install vim on Ubuntu
  ansible.builtin.apt:
	  name: vim
```
здесь мы устанавлеваем vim при помощи модуля ansible.builtin.apt.

role - законченный набор тасков. В последствии их можно использовать в плейбуках. Таким образом это как функции, которые можно прописать один раз, а потом использовать в разных плейбуках. Каждая роль лежит отдельно в своей директории, где лежат директории:
1) defaults - переменные по умолчанию
2) tasks - таски
3) templates - шаблоны
4) files - файлы
5) handlers - подвид тасков
в каждой из этой папки лежит соотвествующий файлы main.yml с ними. Можно создать ещё несколько файлов и подключить их к main файлу.

playbook - это любой законченный вид действий который мы хотим совершить над хостами или груп хостов.
``` yaml
- hosts: my_group
  roles:
	  - example_role
```
Зачастую отдельные таски не заносятся в плэйбук, а заносятся целые роли.

vars - переменные, они могут задаваться по разному:
1) example_role/defaults - переменные используемые по умолчанию для роли, если для конкретного хоста не указываеться чему должна быть равна переменная.
2) host_vars/server-1.yaml - переменные для конкретного хоста (название файла совпадает с названием хоста в файле inventory)
3) group_vars/group_name.yaml - переменные для конкретныой группы
4) переменные отдельно в плейбуке
5) переменные в записи в файле inventory
Сначала переменная будет искаться у хоста, если она не объявлена в соотвествующем файле, то будет искаться у группы, к которой хост привязан, и только в самом крайнем случае перейдёт к defaults.
Часто удобно занасить все хосты в группу all и задавать для неё переменные, которые будут работать для всех хостов.

### Простейшие модули

Установка пакета:
``` yaml
name_module:
	name: название_пакета
	state: latest
```
по умолчанию state стоит latest, т.е. самая последняя версия. Названия модуля зависит от пакетного менеджера.

Работа с файлами (копирование с локального хоста на сервер и т.д. и т.п.):
``` yaml
name_module:
	src: путь до файла на локальной машине
	dest: путь на удалённой
	owner: владелец
	group: группа
	mode: 755
```

### Файл конфигурации

Файл с конфигами должен храниться в той же директории в которой мы создаём инфроструктуру для конкретного проекта, мы называем его ansible.cfg и указываем слежующие важные строчки конфигурации:
```
[defaults]
inventory = ./inventory # где находиться файл inventory
roles_path = ./roles # где лежат прописанные роли
host_key_checking = false # не будет происходить проверки 
						  # сервера при подключении с клиента
```

### Инвентарь и нужные переменные

Основные переменные которые нужны:
1) ansible_host - ip хоста к которому подключаемся
2) ansible_port - какой порт слушает ssh на этом хосте
3) ansible_user - под кем заходит на хосте
4) ansible_become_pass - пароль для того что бы выполнять команды с sudo

Если shh сервер принимает аутентификацию по поролю (что не безопасно!!!), то достаточно указать пароль пользователя в переменную:
5) ansible_ssh_pass - устаревший и не универсальный вариант
6) ansible_password - тоже самое но новый и рекомендуемый, так как он может использоваться не только для ssh подключения, но и для других похожих утелит.

Если происходит вход по rsa ключу, то надо указать переменную:
7) ansible_ssh_private_key_file - адрес до закрытого ключа
Конечно перед этим надо добавить свой id_rsa.pub с ansible сервера в authorization_keys на хосте.


можно использовать команду для проврки доступа ко всем хостам:
``` bash
ansible all -m ping
```

Хосты можно распределять в группы, для этого перед следующими несколькими хостами, которые мы объединим в одну группу мы ставим \[\] c названием группы. Можно создавать новые группы при помощи объединения старых, это записывается так:
``` yaml
[new_group:children]
group7
group13
...
```
Таким образом новая составленная группы new_group будет состоять из хостов входящих в группы group7 и group13.
Все хосты изначально всегда лежат в группе all.

### Плейбуки

В плейбуке пеерчисляеться список play которые будут выполнены последовательно после запуска playbook. Каждый play записываеться как элемент списка ("- " в yaml) и в него могут входить следующие параметры:
* name - название
* hosts - хосты или группы хостов (можно указывать через запятые) над которыми будут происходить действия
* become - булевая переменная (true/false), которая при true позволит пользоваться правами суперпользователя для совершения действий, некоторым модулям это может быть необходимо (также для хоста, в таком случае, надо прописать переменную ansible_become_pass).
* vars - здесь можно указать переменные которые будут использоваться в этом play (записываеться как словарь, где названиие переменной - ключ, а её значение - значение пары).
* tasks - после этого отрибута идёт список ("- ") тасков которые будут актевированы. В отдельный таск может входить название таска (name: str) и модуль (<название модуля>: ...) которые будет проигрываться. Также в аттрибут register можно вписать название переменной, в которую мы хотим, чтобы записывался вывод операционной системы на наши действия.
* roles - этот атрибут принимает список из ролей которые будут использованы.

Плейбуки запускаються при помощи команды ansible-playbook <название плейбука>.

### Модули

1) shell, command - Набор команд в терминале
	* в качестве аргумента принимает список команд
2) file - Создаёт файл
	* path - где создасть и какое имя
	* owner - указать владельца файла
	* group - какая группа сможет иметь доступ к файлу
	* mode - например 0755
	* state - что сделать
		1) touch - создать указанный файл
		2) file - без других параметров выдаст информацию о файле, иначе применит новые веедённые параметры к нему
		3) directory - создаст директорию и все нужные директории под ней.
3) copy - копирует файл
	* src - откуда копируем
	* dest - куда копируем и как переименовываем
	* Аналогичные параметры как и для модуля file
4) debug - помогает отслеживать ошибки
	* msg - выведет это сообщение
	* var - выведет значение этой переменной (но msg и var друг друга взаимоисключают, т.е. можно выбрать только что то одно)
5) apt - работа с пакетным менеджером apt
	* update_cache - если true, то обновит список пакетов
	* upgrade - если true, то обновляет все установленные пакеты
	* pkg <название> - устанавливает пакет. Если же дан список, то будут установлены все пакеты из этого списка.
	* state - используеться после pkg чтобы указать как действовать модулю:
		1) present - если модуль установлен - всё ок, иначе установит
		2) latest - устнаовит модуль если его нет и обновит его, если он не последней версии
		3) absent - удалит нужный пакет, ну или убедиться что он удалён
6) copy - копирует файл (или директорию рекурсивно) на хост
	* dest - куда копировать и название
	* src - что копировать
	* remote_src - если true, то копирует файл с управляемого хоста на него же, если false (по умолчанию) то файл с ansible сервера на управляемый хост.
	* mode, owner, group и т.д. - везде похожие
7) user
	* append - если true, то создаёт пользователя, иначе просто добавит его в группу (это стоит по умолчанию)
	* shell - какой shell будет по умолчанию включаться (/bin/bash как обычно).
	* groups - в какие группы на этом хосте его добавить
	* name - его имя
	* home - директория с его файлами (обычно /home/<имя пользователя>)
8) group
	* name - имя группы
	* state - если present и группы нет, то создаст, если absent и группа есть, то удалит
9) set_fact - здесь мы задаём новые переменные которые сможем использоватль в дальнейшем. Таким образом значения этого модуля - словарь, где ключи названия переменных, а значения те значения которые мы им передадим. Прикол в том, что они могут быть динамическими, т.е. выбираться по разному на разных хостах.
10) setup - выдаёт информацию о хосте
11) template - копирует файл с ansible сервера в формате .j2 (формат для шаблонов Jinja) на управляемый хост, подставляя все значения в шаблон и т.д. Наипростейшее использование, это в файле с форматом .j2 делать вставки  типа {{variables_name}}, в которые при переносе будут подставляться значения.
	 * src - откуда копировать
	 * dest - куда
	 * mode, ... - аналогично как и с прошлыми файлами

### Использование переменных и циклы

К переменным в плейбуках можно обращаться как "{{<название переменной>}}". Значение переменной должно быть соответствующего типа. Некоторые аттрибуты принимают даже списки и словари.

Иногда появляеться нужда выполнить один и тот же модуль несколько раз для разных значений. Тогда в task мы можем добавить аттрибут loop который принимает список как значение (список мы можем как написать, так и передать как переменную). Тогда этот модуль выполниться столько раз, сколько элементов в переданном списке, и каждый раз он будет подставляться заместо "{{item}}" значение этого элемента списка.
Если в качестве элемента списка храниться словарь, то мы аналогично можем обращаться в модуле к отдельным значениям словаря как "{{item.key1}}", "{{item.key2}}" и так далее.

Пример:
``` yaml
- name: Create Folder
  file:
    path: "home/{{item}}"
    state: directory
  loop:
    - "dir1"
    - "dir2"
```

### Блоки и условия

В списке тасков (в описании play используя аттрибут tasks или же в отдельном файле для роли) мы можем указать целый блок тасков при помощи атрибута block. В этот атрибут мы подаём список из тасков.

На блоки и отдельные таски можно накладывать условия когда они будут выполняться, это делаеться при помощи аттрибута when в который подаёться предикат написанный в стиле python.

Пример:
``` yaml
- block:
  
  - name: task 1
    debug:
      msg: "doing task 1"
      
  - name: task 2
    debug:
      msg: "doing task 2"

  when: ansible_hostname == "vadim"
  
- name: task 3
  debug:
    msg: "doing task 2"
  when: ansible_hostname != "vadim"
```

### Роли

Быстро создать роль можно при помощи команды:
``` yaml
ansible-galaxy init <название роли>
```

В случае использования ролей, пути до файлов, которые мы копируем не надо прописывать!! необходимо только название, потому что роль всегда их будет искать в папке files. Аналогично и для шаблонов нам нужно указывать только их названия, так как они сами все должны лежать в templates.