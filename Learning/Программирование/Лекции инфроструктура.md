
# Введение в DevOps

waterfall - жёстко планируем всё и жёстко следуем плану, без всяких отклонений.

agile - план меняеться. Происходят быстрые спринты, после чего делают выводы и адаптируют план к следующему спринту.

CI/CD - (continuous integration / continuous (deployment or delivery)) первая часть говорит о том, что изменение кода сразу влечёт интеграцию во всю систему, всё сразу начинает применяться у всех. CD следующая фаза после CI предпологающая deploy. Основные воплощения CI/CD: GitLab, Jenkins и Azure Pipelines.

deploy - развёртывание на сервере.

pipeline - конвеер, трубопровод, 

# Docker

/var/lib/docker - здесь хранятся данные докрера, но в нём всё сложно, лучше в него не лезть

У контейнеров есть свои ip!! Их можно посмотрть
При скачивании образа, качаеться и вся обвязка для его работы. Например если у нас статит debian, а прога написана и использует библиотеки из centos, то docker докачает все нужные библиотеки.
В Dockerfile - записываеться как создаються образы.

Если попростому: контейнер это маленькая виртуальная машина на локальном хосте, которая запускаеться докером и работает. Образ контейнера - это удобный скомпанированный файл со всеми нужными библиотеками и самим контейнером. В последствии очень удобно обмениваться этими образами по DockerHub, а потом развёртываються как контейнеры на отдельных хостах.

#### Команды

docker - основная команда, после неё идут другие команды:
1) version - показывает версию
2) ps - показывает все запущенные контейнеры
3) ps -a - все контейнеры в системе
4) images - показывает все образы
5) run <имя образа> - создать новый образ, если не находит, то качает
6) start <имя образа> - запускает образ
7) stop <> - останавливает образ
8) exec -it <хэш> /bin/bash - заходит в запущенный контейнер. Там всё как на виртуальное машине, но с минимальнейшей обвязкой. У него есть своя система, ядро у него совпадает с хостовым, у него свои процессы запущены. Все файлы которые контейнер хранит конечно же лежат на хосте.
9) logs <хэш> - показывает логи
10) container
	1) rm <хэш> - удаляет контейнер
11) push <название> - отправляет образ на репозиторий в dockerhub
12) login -u <название репозитория> - подключаемся к репозиторию dockerhub
13) pull <название> - копирует образ на локальный хост
14) compose -f <путь к yaml файлу> up -d - устанавливает всё красивенько по списку все контейнеры, и всё уже готово к работе
15) compose -f <путь к yaml файлу> down - удаляет все контейнеры

# GitLab CI/CD

Это типа GitHub, но с возможностью создания pipeline'ов. Есть аналог Jenkins, который представляет из себя только CI/CD инструмент, и может использовать разные инструменты контроля версий. GitLab же, кроме CI/CD инструментов имеет большую кучу других фич.
Все настройки по пайплайну находяться в файле .gitlab-ci.yml. По умолчанию при всех пушах этот файлик будет выполняться.
У gitlab большое количество переменных окружения которые можно использовать в пайплайне. Их можно задавать параметром variables в yml файле.
Ранеры это машины на которых происходит вычисление, на них можно повесить теги (назвать просто). Затем в отдельных job можно указать нужные теги для ранера.

# Ansible

Это декларативный инструмент, мы описываем что мы хотим видеть, а ansible это должен сделать, и убедиться что всё работает (нам не важно как это будет выполняться). В ansible мы записываем желаемое состояние сервере, и в будущем можем устанавливать состояния на сервере или проверять стоит ли состояние на сервере.
Ansible Galaxy - репозиторий с модулями для ansible/
Основные определения:
1) Ansible Playbook - задачи, что должно быть, что мы хотим видеть
2) Ansible Inventory - описание хостов. В нём описываються все машины, их группы, ip, порты, ssh ключи, под кем заходить.
3) ansible.cfg - содержит конфиги
	1) inventory=<название файла> - указание какой файл Ansible Inventory

#### Команды

1) ansible-playbook <файл.yaml> - запускает "план" Ansible Playbook.

# Terraform

Тоже декларативный инструмент похожий на Ansible, но он не совсем opensorce.
Он используеться для развёртывания виртуальных машин на серверах и облоках. Обычно Terraform и Ansible используються совместно.

# Kubernetes (k8s)

Это проагрейженный docker-compose, т.е. он используеться для разворачивания систем из нескольких контейнеров автоматически при помощи конфигурационного файла.
Одна из его фишек - self-healling, т.е. постоянно пытаеться поддерживать состояние системы и восстанавливает её. Это всё возможно из-за statefull работы k8s, он помнит что у него работает, не работает, и что надо сделать. Docker compose так не делает, он stateless, он поставил контейнеры и забыл, востановить при поломке системы он не сможет.
Kubernetes ещё может работать на нескольких нодах, что позволяет реализовать отказоустойчивость. Также он работает и на облоках.

##### Архитектура

У кубера есть несколько типов нод (которые составляют в кластер):
	1) Master Node - управляющая нода. Содержит все конфигурации и управляет всеми рабочими нодами. Если она упадёт, то сервисы продолжат работать, но регулировать их работу не получиться. Если упадёт сервис, это не заденет управляюшую ноду и она всё починит.
	2) Worker node - исполнительная нода. Держит на себе работающие контейнеры.

Поды это объединение конейнеров. Это минимальный объект для работы в кубере. Контейеры в них уже связаны и могут. 

Kube-Sheduler - встроенный планировщик.

Манифест - это декларативный конфиг. В нём указания примерно как в ansible.

namespace - объект кластера, так называемый виртуальный кластер.
##### Команды

1) kubectl
	1) drain <нода> - освобождает ноду от нагрузки
	2) delete nodes <нода> - удаление
	3) get pod - показывает все поды и на каких нодах они стоят
	4) cordone <нода> - ставит ноду на настройку и на время выводит из работы
	5) uncordone <нода> - применяет настройки и запускает ноду